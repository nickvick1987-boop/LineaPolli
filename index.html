<!doctype html>
<html lang="it">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<meta name="author" content="Vick"/>
<title>LineaPolli ‚Äî Production Tracker</title>
<link rel="icon" href="#logo-minimal"/>
<script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
<script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
<script src="https://cdn.tailwindcss.com"></script>
<style>
  /* Small tweaks for standalone (Tailwind used for main styles) */
  body { background: #f3f4f6; }
</style>
<!-- Inline SVG logos for favicon and use -->
<svg xmlns="http://www.w3.org/2000/svg" style="display:none;">
  <symbol id="logo-minimal" viewBox="0 0 64 64">
    <!-- minimal line chicken + gear -->
    <g fill="none" stroke="currentColor" stroke-width="2">
      <path d="M20 36c6-8 14-8 20-4 6 4 6 12 0 16-6 4-14 2-20-6" />
      <circle cx="18" cy="28" r="2" fill="currentColor"/>
      <path d="M42 22c4-2 8-1 10 3" />
      <g transform="translate(44,12) scale(0.6)">
        <circle cx="8" cy="8" r="6" stroke-width="1.4"/>
        <path d="M8 2v3M8 14v-3M2 8h3M14 8h-3M4 4l2.2 2.2M12 12l-2.2-2.2M4 12l2.2-2.2M12 4l-2.2 2.2" stroke-width="1.2"/>
      </g>
    </g>
  </symbol>

  <symbol id="logo-cartoon" viewBox="0 0 120 120">
    <!-- playful chicken + cog -->
    <g>
      <ellipse cx="48" cy="64" rx="26" ry="20" fill="#FFD66B" stroke="#E6A800" stroke-width="2"/>
      <circle cx="36" cy="54" r="3" fill="#000"/>
      <path d="M58 56c6-2 10 0 14 4" stroke="#E6A800" stroke-width="3" fill="none" stroke-linecap="round"/>
      <g transform="translate(78,28) scale(0.6)">
        <circle cx="16" cy="16" r="12" fill="#D1E3FF" stroke="#7AA7FF" stroke-width="2"/>
        <path d="M16 4v5M16 28v-5M4 16h5M28 16h-5" stroke="#7AA7FF" stroke-width="1.8"/>
      </g>
    </g>
  </symbol>
</svg>

  <link rel="manifest" href="/manifest.json">
  <link rel="icon" href="/icons/icon-192.png" sizes="192x192" type="image/png">
</head>
<body class="min-h-screen font-sans antialiased">

<div id="root"></div>

<script type="text/babel">
const {useState,useEffect,useRef} = React;

/* Utility: localStorage helper */
function save(key, value){ try{ localStorage.setItem(key, JSON.stringify(value)); }catch(e){} }
function load(key, fallback){ try{ const v = localStorage.getItem(key); return v ? JSON.parse(v) : fallback; }catch(e){ return fallback; } }

function nowISO(ts=Date.now()){ return new Date(ts).toLocaleString(); }

function LineaPolliStandalone(){
  // load persisted or defaults
  const [totalPieces, setTotalPieces] = useState(()=>load('lp_totalPieces',500));
  const [piecesPerMinute, setPiecesPerMinute] = useState(()=>load('lp_ppm',2));
  const [produced, setProduced] = useState(()=>load('lp_produced',0));
  const producedRef = useRef(produced);

  const [running, setRunning] = useState(()=>load('lp_running',false));
  const [paused, setPaused] = useState(()=>load('lp_paused',false));
  const [pauseMode, setPauseMode] = useState(()=>load('lp_pauseMode','none'));

  const [autoPauseEvery, setAutoPauseEvery] = useState(()=>load('lp_autoEvery',60));
  const [autoPauseDuration, setAutoPauseDuration] = useState(()=>load('lp_autoDuration',10));
  const [autoPauseCountdown, setAutoPauseCountdown] = useState(0);

  const workSinceLastAutoRef = useRef(load('lp_workSince',0));
  const manualPauseStartRef = useRef(null);

  const [pausesLog, setPausesLog] = useState(()=>load('lp_pausesLog',[]));

  // persist on change of key-values
  useEffect(()=> save('lp_totalPieces', totalPieces), [totalPieces]);
  useEffect(()=> save('lp_ppm', piecesPerMinute), [piecesPerMinute]);
  useEffect(()=> save('lp_produced', produced), [produced]);
  useEffect(()=> save('lp_running', running), [running]);
  useEffect(()=> save('lp_paused', paused), [paused]);
  useEffect(()=> save('lp_pauseMode', pauseMode), [pauseMode]);
  useEffect(()=> save('lp_autoEvery', autoPauseEvery), [autoPauseEvery]);
  useEffect(()=> save('lp_autoDuration', autoPauseDuration), [autoPauseDuration]);
  useEffect(()=> save('lp_workSince', workSinceLastAutoRef.current), []); // saved on key transitions below
  useEffect(()=> save('lp_pausesLog', pausesLog), [pausesLog]);

  // audio
  const audioRef = useRef(null);
  useEffect(()=>{
    try{
      const ctx = new (window.AudioContext||window.webkitAudioContext)();
      const o = ctx.createOscillator(); const g = ctx.createGain();
      o.type='sine'; o.connect(g); g.connect(ctx.destination); o.start();
      audioRef.current={ctx,o,g};
    }catch(e){audioRef.current=null;}
    return ()=>{
      try{ if(audioRef.current){ audioRef.current.o.stop(); audioRef.current.ctx.close(); }}catch(e){}
    }
  },[]);

  // ticker for producing pieces and auto-pause logic
  useEffect(()=>{
    let last = Date.now();
    let raf = null;
    function step(){
      const now = Date.now();
      const dt = (now-last)/1000; last = now;
      if(running && !paused){
        // produce
        const delta = (piecesPerMinute/60)*dt;
        producedRef.current += delta;
        if(producedRef.current >= totalPieces){
          producedRef.current = totalPieces;
          setProduced(producedRef.current);
          setRunning(false);
          // beep
          try{
            const {ctx,g} = audioRef.current;
            const t = ctx.currentTime;
            g.gain.setValueAtTime(0.001,t);
            g.gain.exponentialRampToValueAtTime(0.5,t+0.01);
            g.gain.exponentialRampToValueAtTime(0.001,t+0.6);
          }catch(e){}
        } else {
          setProduced(producedRef.current);
        }
        // accumulate work time
        workSinceLastAutoRef.current += dt;
        // save workSince occasionally
        if(Math.random()<0.02) save('lp_workSince', workSinceLastAutoRef.current);
        // auto pause check
        if(autoPauseEvery>0 && autoPauseDuration>0){
          if(workSinceLastAutoRef.current >= autoPauseEvery*60){
            // start auto pause
            startAutoPause();
          }
        }
      }
      raf = requestAnimationFrame(step);
    }
    raf = requestAnimationFrame(step);
    return ()=> cancelAnimationFrame(raf);
  }, [running, paused, piecesPerMinute, totalPieces, autoPauseEvery, autoPauseDuration]);

  // helper to start auto pause
  const autoTimerRef = useRef(null);
  function startAutoPause(){
    if(paused) return;
    setPaused(true); setPauseMode('auto');
    const duration = Math.round(autoPauseDuration*60);
    setAutoPauseCountdown(duration);
    const startTs = Date.now();
    autoTimerRef.current = setInterval(()=>{
      setAutoPauseCountdown(prev=>{
        if(prev<=1){
          clearInterval(autoTimerRef.current);
          const endTs = Date.now(); const dur = Math.round((endTs-startTs)/1000);
          setPausesLog(prevLog=> [{type:'Automatica', start:startTs, end:endTs, durationSec:dur}, ...prevLog]);
          workSinceLastAutoRef.current = 0; save('lp_workSince',0);
          setPaused(false); setPauseMode('none'); setAutoPauseCountdown(0);
          return 0;
        }
        return prev-1;
      });
    },1000);
  }

  // manual pause toggle
  function toggleManualPause(){
    if(!running) return;
    if(!paused){
      manualPauseStartRef.current = Date.now();
      setPaused(true); setPauseMode('manual');
    } else {
      if(pauseMode==='manual'){
        const end = Date.now(); const start = manualPauseStartRef.current||end; const dur = Math.round((end-start)/1000);
        setPausesLog(prev=> [{type:'Manuale', start, end, durationSec:dur}, ...prev]);
        manualPauseStartRef.current = null;
        setPaused(false); setPauseMode('none');
      } else if(pauseMode==='auto'){
        // user resumes early during auto pause -> log and stop auto timer
        if(autoTimerRef.current) clearInterval(autoTimerRef.current);
        const end = Date.now();
        const startedApprox = end - (autoPauseDuration*60 - autoPauseCountdown)*1000;
        const dur = Math.round((end-startedApprox)/1000);
        setPausesLog(prev=> [{type:'Automatica', start:startedApprox, end, durationSec:dur}, ...prev]);
        workSinceLastAutoRef.current = 0; save('lp_workSince',0);
        setPaused(false); setPauseMode('none'); setAutoPauseCountdown(0);
      }
    }
  }

  function handleStart(){ setRunning(true); setPaused(false); setPauseMode('none'); }
  function handleStop(){
    setRunning(false);
    if(paused && pauseMode==='manual'){
      const end = Date.now(); const start = manualPauseStartRef.current||end; const dur = Math.round((end-start)/1000);
      setPausesLog(prev=> [{type:'Manuale', start, end, durationSec:dur}, ...prev]);
      manualPauseStartRef.current = null;
    }
    setPaused(false); setPauseMode('none');
  }

  function handleReset(){ setRunning(false); setPaused(false); setPauseMode('none'); setProduced(0); producedRef.current=0; workSinceLastAutoRef.current=0; setPausesLog([]); setAutoPauseCountdown(0); save('lp_workSince',0); }

  // derived
  const remaining = Math.max(0, Math.ceil(totalPieces-produced));
  const percent = Math.min(100, (produced/totalPieces)*100 || 0);
  const baseSeconds = piecesPerMinute>0 ? (Math.max(0,totalPieces-produced)/piecesPerMinute)*60 : Infinity;
  const pauseEverySec = autoPauseEvery*60; const pauseDurSec = autoPauseDuration*60;
  const futurePauses = (autoPauseEvery>0 && autoPauseDuration>0 && isFinite(baseSeconds)) ? Math.floor(baseSeconds/pauseEverySec) : 0;
  const totalPauseSeconds = pausesLog.reduce((s,p)=>s+(p.durationSec||0),0);
  const estimated = baseSeconds + futurePauses*pauseDurSec + totalPauseSeconds;

  // save key changes when they happen
  useEffect(()=> save('lp_totalPieces', totalPieces), [totalPieces]);
  useEffect(()=> save('lp_ppm', piecesPerMinute), [piecesPerMinute]);
  useEffect(()=> save('lp_pausesLog', pausesLog), [pausesLog]);

  // small saved indicator
  const [savedBlink, setSavedBlink] = useState(false);
  useEffect(()=>{ setSavedBlink(true); const t=setTimeout(()=>setSavedBlink(false),800); return ()=>clearTimeout(t); }, [totalPieces,piecesPerMinute,produced,running,paused,autoPauseEvery,autoPauseDuration,pausesLog]);

  // circular params
  const size=160, stroke=14, radius=(size-stroke)/2, circ=2*Math.PI*radius, offset = circ - (percent/100)*circ;
  const hue = Math.round(120 - 120*(percent/100));

  return (
    <div className="max-w-5xl mx-auto p-6">
      <header className="flex items-center justify-between mb-6">
        <div className="flex items-center gap-3">
          <svg width="44" height="44" viewBox="0 0 64 64" className="text-yellow-500"><use href="#logo-minimal" /></svg>
          <div>
            <div className="text-xl font-bold">LineaPolli</div>
            <div className="text-xs text-gray-600">Creato da Vick ‚Äî LineaPolli ¬© 2025</div>
          </div>
        </div>
        <div className="text-sm text-gray-500">Autore: Vick</div>
      </header>

      <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
        <div className="space-y-4">
          <div className="p-4 border rounded bg-white">
            <div className="text-sm font-medium">Totale pezzi</div>
            <input className="mt-2 w-full border rounded p-2" type="number" value={totalPieces} onChange={e=>setTotalPieces(Number(e.target.value)||0)} />
            <div className="text-sm font-medium mt-3">Pezzi / minuto</div>
            <input className="mt-2 w-full border rounded p-2" type="number" step="0.01" value={piecesPerMinute} onChange={e=>setPiecesPerMinute(Number(e.target.value)||0)} />
          </div>

          <div className="p-4 border rounded bg-white">
            <div className="text-sm font-medium">Pausa automatica</div>
            <div className="grid grid-cols-2 gap-2 mt-2">
              <div>
                <div className="text-xs">Ogni (min)</div>
                <input className="mt-1 w-full border rounded p-2" type="number" min="0" value={autoPauseEvery} onChange={e=>setAutoPauseEvery(Number(e.target.value)||0)} />
              </div>
              <div>
                <div className="text-xs">Durata (min)</div>
                <input className="mt-1 w-full border rounded p-2" type="number" min="0" value={autoPauseDuration} onChange={e=>setAutoPauseDuration(Number(e.target.value)||0)} />
              </div>
            </div>
            <div className="text-xs text-gray-500 mt-2">La pausa parte dopo X minuti effettivi di lavoro.</div>
          </div>

          <div className="p-4 border rounded bg-white">
            <div className="flex gap-2">
              {!running ? <button className="flex-1 bg-green-600 text-white py-2 rounded" onClick={handleStart}>Avvia</button> : <button className="flex-1 bg-red-600 text-white py-2 rounded" onClick={handleStop}>Ferma</button>}
              <button className={"px-4 py-2 rounded "+(paused?'bg-yellow-400':'bg-gray-200')} onClick={toggleManualPause}>{paused?'Riprendi':'Pausa'}</button>
            </div>
            <button className="w-full mt-2 border rounded py-2 bg-gray-50" onClick={handleReset}>Reset (azzera tutto)</button>
            <div className="mt-3 text-xs text-gray-600">Totale pause: {Math.round(totalPauseSeconds/60*10)/10} min</div>
            <div className="text-xs text-gray-600">Pause registrate: {pausesLog.length}</div>
          </div>
        </div>

        <div className="flex flex-col items-center bg-white p-4 rounded border">
          <div className="relative">
            <svg width={size} height={size} viewBox={`0 0 ${size} ${size}`}>
              <g transform={`translate(${size/2}, ${size/2})`}>
                <circle r={radius} fill="transparent" stroke="#eee" strokeWidth={stroke} />
                <circle r={radius} fill="transparent" stroke={`hsl(${hue} 100% 40%)`} strokeWidth={stroke} strokeLinecap="round"
                  strokeDasharray={circ} strokeDashoffset={offset} transform="rotate(-90)" style={{transition:'stroke-dashoffset 0.4s linear, stroke 0.4s linear'}} />
              </g>
            </svg>

            <div className="absolute inset-0 flex flex-col items-center justify-center">
              <div className="text-2xl font-bold">{remaining}</div>
              <div className="text-xs text-gray-600">pezzi rimanenti</div>
              <div className="mt-1 text-sm font-semibold">{percent.toFixed(1)}%</div>
            </div>
          </div>

          <div className="w-full mt-4">
            <div className="w-full bg-gray-200 rounded-full h-3 overflow-hidden">
              <div className="h-3 rounded-full" style={{width: percent+'%', background:'linear-gradient(90deg, hsl(120 100% 40%), hsl(60 100% 40%), hsl(0 100% 40%))'}}></div>
            </div>
          </div>
          <div className="mt-3 text-sm text-gray-600">Tempo stimato rimanente: {formatTime(estimated)}</div>
          {paused && pauseMode==='auto' && <div className="mt-3 w-full p-3 bg-yellow-50 text-sm rounded border">‚è∏ Pausa automatica ‚Äî ripresa in {formatTime(autoPauseCountdown)}</div>}
          {paused && pauseMode==='manual' && <div className="mt-3 w-full p-3 bg-yellow-50 text-sm rounded border">‚úã Pausa manuale ‚Äî premi Riprendi per terminare</div>}
        </div>

        <div className="bg-white p-4 rounded border">
          <div className="text-sm font-medium mb-2">Registro pause (ultima in cima)</div>
          {pausesLog.length===0 ? <div className="text-xs text-gray-500">Nessuna pausa registrata</div> : (
            <div className="overflow-auto max-h-64">
              <table className="w-full text-xs">
                <thead><tr className="text-left text-gray-600"><th>Tipo</th><th>Inizio</th><th>Fine</th><th className="text-right">Durata</th></tr></thead>
                <tbody>
                  {pausesLog.map((p,i)=>(
                    <tr key={i} className="border-t">
                      <td className="py-2">{p.type}</td>
                      <td className="py-2">{nowISO(p.start)}</td>
                      <td className="py-2">{nowISO(p.end)}</td>
                      <td className="py-2 text-right">{Math.round(p.durationSec/60*10)/10} min</td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          )}
          <div className="mt-3 text-xs text-gray-500">Nota: il log si azzera con Reset.</div>
        </div>
      </div>

      <footer className="mt-8 text-center text-xs text-gray-500">
        <div>üêî LineaPolli ‚Äî Creato da Vick ¬© 2025</div>
      </footer>

      <div style={{position:'fixed', right:12, bottom:12}}>
        <div className={"px-3 py-2 rounded shadow "+(savedBlink?'bg-green-600 text-white':'bg-white text-gray-700')}>
          üíæ Dati salvati automaticamente
        </div>
      </div>
    </div>
  );
}

ReactDOM.createRoot(document.getElementById('root')).render(<LineaPolliStandalone />);
</script>


<script>
if ('serviceWorker' in navigator) {
  window.addEventListener('load', function() {
    navigator.serviceWorker.register('/service-worker.js').then(function(reg){
      console.log('SW registered', reg);
    }).catch(function(err){ console.warn('SW reg failed', err); });
  });
}
</script>
</body>
</html>
